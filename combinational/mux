module MUX_case(output reg Y, input A, B, C, D, input [1:0] S);
    always @(*) begin
        case(S)
            2'b00: Y = A;
            2'b01: Y = B;
            2'b10: Y = C;
            2'b11: Y = D;
            default: Y = 1'b0; // Default case to avoid latches, it can have the value of x,z,1,0, unknown cases means the previous value is infered, thus we need a latch to store the previous value
        endcase
    end
endmodule



module MUX_if(output reg Y, input A, B, C, D, input [1:0] S);
    always @(*) begin
        if (S == 2'b00)
            Y = A;
        else if (S == 2'b01)
            Y = B;
        else if (S == 2'b10)
            Y = C;
        else if (S == 2'b11)
            Y = D;
        else
            Y = 1'b0; // Many synthesis tools can optimize case statements efficiently, so if large number of conditions go for case
    end
endmodule


module MUX_bitwise(output Y, input A, B, C, D, input [1:0] S);
    assign Y = (~S[1] & ~S[0] & A) | (~S[1] & S[0] & B) | (S[1] & ~S[0] & C) | (S[1] & S[0] & D);//direvtly maps to hardware , but complex in nature
endmodule

